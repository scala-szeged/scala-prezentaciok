| \gScala alapok elõadás


'\bn\s' - next (\ENTER\s -t is kell nyomni)
'\bb\s' - back
'\b7 go\s' - go to slide 7
'\br\s' - run
'\bh\s' - help

---
Import teljes package -re:

```
import scala.io._
```


Közönséges class -ok:

```
class A(age: Int)
val a = new A(10)
// nem elérhetõ mezõ: a.age

class B(val name: String) {
    override def toString = s"B($name)"
}
val b = new B("Dezsõ")
// elérhetõ mezõ: b.name
```
---
Interface és Singleton Scala -ban:

```
trait Greeter {
    def sayHello: Unit
}

trait NameHolder {
    def getName: String
}

object HelloWorld extends Greeter with NameHolder {
    def sayHello = println("Hello " + getName)
    def getName = "World"
}
```

próbáld ki:
HelloWorld.sayHello
---
case class -ok:

```
case class Person(name:String, age:Int)

val adam = Person("Ádám", 42)
```

A case class -okkal ezeket is kapjuk: hashcode, equals, toString
Plusz serializable lesz az objektumunk
---
```
case class Person(name:String, age:Int)

val adam = Person("Ádám", 42)

adam.name = "Éva"
```

Eredmény:

<console> error: reassignment to val
       adam.name = "Éva"
---
Mivel a mezõk nem írhatóak helyette ezt kell csinálni:


```
case class Person(name:String, age:Int)

val adam = Person("Ádám", 42)

adam.copy(name = "Éva")
```
---
Mezõk


```
val page: Int = 17
var num = 56
```
page nem változtatható, num viszont változtatható
---
Metódusok, illetfe függvények

```
def isMajor1(p: Person): Boolean = {p.age >= 18} // jó
def isMajor2(p: Person): Boolean = p.age >= 18 // jó
def isMajor3(p: Person) = p.age >= 18 // jó
def isMajor4(p: Person) = {p.age >= 18} // jó
def isMajor5(p: Person) {p.age >= 18} // nem jó

def makeItDouble(x: Int): Int = {
    val y = 2 * x
    println(y)
    y
}
```
---
Függvények, folytatás



```
case class Person(name:String, age:Int)


val isMajorUs: Int => Boolean =   age => age >= 21
val isMajorHu: Int => Boolean = { age => age >= 18 }

// Magasabb rendű függvények

def isMajorPerson(p: Person, predicate: Int => Boolean): Boolean = {
    predicate(p.age)
}

val IsJohnMajor = isMajorPerson(Person("John", 18), isMajorUs)
val jánosNagykorúE = isMajorPerson(Person("János", 18), isMajorHu)
```



---
Pattern matching


```
def prefix(word: String) = word.toLowerCase.head match {
 case 'ö'|'ü'|'ó'|'e'|'u'|'i'|'o'|'ő'|'ú'|'a'|'é'|'á'|'ű'|'í' => "az"
 case x => "a"
}

val e = "ember"
val o = "Operaház"
val ks = "Király Sanyi"

val aze = prefix(e) + " " + e
val azo = prefix(o) + " " + o
val aks = prefix(ks) + " " + ks
```
---
Pattern matching folytatás


```
case class Customer(name:String, company:Option[String], city:String)

def whoIsThis(c: Customer) = c match {
    case Customer(name, _, "Budapest") => s"$name is a local"
    case Customer(name, _, city) => s"$name is a visitor from $city"
}

val klara = Customer("Bito Klára", Some("DekorIt"), "Budapest")
whoIsThis(klara)

val sandor = Customer("Nagy Sándor", None, "Szeged")
whoIsThis(sandor)
```
---
Pattern matching több mélységben:

sealed abstract class Option[+A]()
case class Some[+A](val x : A) extends scala.Option[A]
case object None extends scala.Option[scala.Nothing]

```
case class Customer(name:String, company:Option[String], city:String)

def whoIsThis(c: Customer) = c match {
    case Customer(name, _, "Budapest") => s"$name is a local"
    case Customer(name, Some(co), city) =>
        s"$name is a visitor from $city working at ${co}"
    case Customer(name, None, city) => s"$name is a visitor from $city"
}

val gabor = Customer("Csúri Gábor", Some("Arcél"), "Szeged")
whoIsThis(gabor)

val sandor = Customer("Nagy Sándor", None, "Szeged")
whoIsThis(sandor)
```
---
\bcase _ =>\s teszi kimerítõvé a matching -et
mint Javában a switch -et a default:

```
def onKeyPress(keyCode: Value) = keyCode match {
    case Left  => ui.left()
    case Right => ui.right()
    case Up    => ui.up()
    case Down  => ui.down()
    case Space => ui.space()
    case _ =>
  }
```
---
Adatstruktúrák, List


```
val list = List(1, 2, 3, 4)
val h = list.head
val t = list.tail
val nulladik = list(0)
```
---
Set


```
val mySet = Set(7,8,9)
val c8 = mySet.contains(8)
val c4 = mySet.contains(4)

val benneVan1 :   Int => Boolean   =   n =>  6 < n && n < 10
val benneVan2 :   Int => Boolean   =   mySet
```
---
Map


```
val myMap = Map(5->"öt", 6->"hat")
val v6 = myMap(6)
val c9 = myMap.contains(9)
val g5 = myMap.get(5)
val g4 = myMap.get(4)

val miVanBenne1 :   Int => String   =   n => n match {
    case 5 => "öt"
    case 6 => "hat"
    case _ => throw new NoSuchElementException("key not found: n")
    }

val miVanBenne2 :   Int => String   =   myMap
---
List folytatás


```
val list = List(1, 2, 3, 4, 5)
val nulladik = list(0)
val h = list.head
val t = list.tail

val (paros, paratlan) = list.partition(x => x % 2 == 0)

val (x,y,z) = (42, 41, 43)

val list2 = 0 :: paros
val list3 = paros ::: paratlan
```
---
For comprehension:

```
for (i <- 1 to 5) {
    println(i)
}

println

for (i <- 1 until 5) {
    println(i)
}
```
---
For comprehension:

```
val xs = List(1, 2, 3, 4, 5)

val f = for (x <- xs if x%2 == 0) yield x*10

// Ugyan az mint:
val fm = xs.filter( _ % 2 == 0).map( _ * 10)
```



while és do while ugyan olyan mint Javában
---
Több szálon iterálás:

```
(1 to 5).par.foreach{ println }
```
---
Példa: IO és Java osztály használata

```
import java.io.{File, PrintWriter}
import scala.io.Source

object Filter extends App {

  private val in = Source.fromFile("/Users/setenyjanos/proba.puml")
  val probaPuml = new File("/Users/setenyjanos/filtered.puml")
  val out = new PrintWriter(probaPuml)

  out.println("@startuml\nleft to right direction")
  in.getLines().foreach { line =>
    if(line.contains("field") || line.contains("button"))
      out.println(line)
  }
  out.println("@enduml")
  out.flush()
  out.close()
}
```
---
TODO: Set, Map
majd később a kombinálhatóság:

K => Boolean helyére Set
K => V helyére Map
